from Bio.PDB import *
import numpy as np
from Bio import SeqIO
import subprocess as sp
from scipy.spatial.transform import Rotation as R
from get_torsion import GetTorsion, CHIS
from amino_acids import modres, longer_names

LIGHT_MAX_LENGTH = 130
HEAVY_MAX_LENGTH = 150
MAX_LENGTH = LIGHT_MAX_LENGTH + HEAVY_MAX_LENGTH
AA_DICT = {"A": 0, "C": 1, "D": 2, "E": 3, "F": 4, "G": 5, "H": 6, "I": 7, "K": 8, "L": 9, "M": 10, "N": 11, "P": 12,
           "Q": 13, "R": 14, "S": 15, "T": 16, "W": 17, "Y": 18, "V": 19, "X": 20} # ,  "-": 21
MODIFIED_AA = modres
THREE_TO_ONE = longer_names
FEATURE_NUM = len(AA_DICT) + 2 + 1 # amino acids + heavy, light columns + transformation column
SURFACE = "surfaceResidues"  # surface <pdb>
MAX_LENGTH_ANTIGEN = 600
MAX_SURFACE_VALUE = 300
CENTER_TRIANGLE = [[-0.826, -0.93966667, -0.09566667], [0.177,0.02833333,-0.53166667],[0.649,0.91133333, 0.62733333]]
ANTIGEN_FEATURE_NUM = len(AA_DICT) + 1 + 1 + 1  # surface column + docking column + contact column
MIN_LENGTH_ANTIGEN = 5
TORSION_CALCULATOR = GetTorsion(chi=[1, 2, 3, 4, 5])

HEADER = "HEADER    IMMUNE SYSTEM - ANTIBODY                           \nTITLE     COMPUTATIONAL MODELING     \nREMARK 777 MODEL GENERATED BY FOLD&DOCK \n"
ATOM_LINE = "ATOM{}{}  {}{}{} {}{}{}{}{:.3f}{}{:.3f}{}{:.3f}  1.00{}{:.2f}           {}\n"
END_LINE = "END\n"
ANTIGEN_HEADER = "HEADER    IMMUNE SYSTEM - ANTIGEN                           \nTITLE     COMPUTATIONAL MODELING     \nREMARK 777 TRANSFORMATION GENERATED BY FOLD&DOCK \n"


def seq_iterator(fasta_file_path):
    """
    iterates over a fasta file
    :param fasta_file_path: path to fasta file
    :return:yields sequence, name
    """
    for seq_record in SeqIO.parse(fasta_file_path, "fasta"):
        yield seq_record


def is_nb(sequence):
    """
    :param sequence: string
    :return: bool
    """
    return ":" not in sequence


def three_to_one(three_letter_code):
    """
    :param three_letter_code: string (len == 3)
    :return: char
    """
    if three_letter_code in MODIFIED_AA:
        three_letter_code = MODIFIED_AA[three_letter_code]

    if three_letter_code not in THREE_TO_ONE:  # BAD amino acid
        return None
    return THREE_TO_ONE[three_letter_code]


def get_seq_aa(pdb_model, only_ca=False):
    """
    :param pdb: pdb file path
    :param chain_letters: chains to extract (ABC for example)
    :param only_ca: take only residues that have a CA atom
    :return: sequence (string), aa residues
    """
    aa_residues = []
    seq = []

    for chain in pdb_model:
        chain_aa = []
        chain_seq = ""
        for residue in chain:
            aa = residue.get_resname()
            if not is_aa(aa) or not three_to_one(aa) or (only_ca and not residue.has_id('CA')):
                continue
            chain_seq += three_to_one(aa)
            chain_aa.append(residue)
        seq.append(chain_seq)
        aa_residues.append(chain_aa)
        return seq, aa_residues


def get_model_with_chains(pdb, chain_letters=None):
    """
    """
    if pdb is not None:
        return None
    model = PDBParser(QUIET=True).get_structure(pdb, pdb)[0]
    if chain_letters is not None:
        for chain in model:
            if chain.get_id() not in chain_letters:
                model.detach_child(chain.get_id())

    # The model doesnt have any of the requested chain ids
    if len(model) == 0:
        raise ValueError("The given antigen pdb {} doesn't have any of the requested chains: {} ".format(pdb, chain_letters))
    return model


def separate_antibody_chains(antibody_sequence):
    """
    """
    chains_seq = antibody_sequence.upper().split(":")
    heavy_seq, light_seq = chains_seq[0], (None if len(chains_seq) == 1 else chains_seq[1])  # Nb / Ab
    return heavy_seq, light_seq


def matrix_to_pdb_antibody(pdb_file, ab_seq, coord_matrix, write_end=True, conf=None):
    """
    convert antibody output to pdb file
    """

    heavy_seq, light_seq = separate_antibody_chains(ab_seq)

    pdb_file.write(HEADER)

    if light_seq is None: # Nanobody
        iter_values = zip([heavy_seq], ["H"], [0])
    else:
        iter_values = zip([heavy_seq, light_seq], ["H", "L"], [0, HEAVY_MAX_LENGTH])

    for heavy_light_seq, HL, pos in iter_values:
        i = 1
        k = 1
        for aa in range(len(heavy_light_seq)):
            second_space = (4 - len(str(i))) * " "
            three_letter_code = three_to_one(heavy_light_seq[aa])
            backbone = ["N", "CA", "C", "O", "CB"]
            chis = []
            for chi in ["chi1", "chi2", "chi3", "chi4", "chi5"]:
                if three_letter_code in CHIS[chi]:
                    chis.append(CHIS[chi][three_letter_code][-1])
            backbone = backbone + chis
            for j in range(len(backbone)):
                x, y, z = coord_matrix[aa + pos][3*j], coord_matrix[aa+ pos][3*j+1], coord_matrix[aa+ pos][3*j+2]
                if x == 0. and y == 0. and z == 0.: # no atom
                    continue
                b_factor = 0.00
                if conf is not None:
                    b_factor = conf[aa + pos]
                sixth_space = (6 - len("{:.2f}".format(b_factor))) * " "
                first_space = (7 - len(str(k))) * " "
                third_space = (12 - len("{:.3f}".format(x))) * " "
                forth_space = (8 - len("{:.3f}".format(y))) * " "
                fifth_space = (8 - len("{:.3f}".format(z))) * " "
                pdb_file.write(ATOM_LINE.format(first_space, k, backbone[j]," " * (4 - len(backbone[j])), three_letter_code,HL, second_space, i, third_space, x,forth_space, y,fifth_space, z, sixth_space, b_factor, backbone[j][0]))
                k += 1
            i += 1
    if write_end:
        pdb_file.write(END_LINE)


def matrix_to_pdb_antigen(pdb_file, antigen_seq, coord_matrix, write_end=True):
    """
    convert antigen output to pdb file
    """
    pdb_file.write(ANTIGEN_HEADER)

    i = 1
    k = 1
    for aa in range(len(antigen_seq)):
        second_space = (4 - len(str(i))) * " "
        three_letter_code = Polypeptide.one_to_three(antigen_seq[aa])
        backbone = ["N", "CA", "C", "O", "CB"]
        chis = []
        for chi in ["chi1", "chi2", "chi3", "chi4", "chi5"]:
            if three_letter_code in CHIS[chi]:
                chis.append(CHIS[chi][three_letter_code][-1])
        backbone = backbone + chis
        for j in range(len(backbone)):
            x, y, z = coord_matrix[aa][3*j], coord_matrix[aa][3*j+1], coord_matrix[aa][3*j+2]
            if x == 0. and y == 0. and z == 0.: # no atom
                continue
            b_factor = 0.00
            sixth_space = (6 - len("{:.2f}".format(b_factor))) * " "
            first_space = (7 - len(str(k))) * " "
            third_space = (12 - len("{:.3f}".format(x))) * " "
            forth_space = (8 - len("{:.3f}".format(y))) * " "
            fifth_space = (8 - len("{:.3f}".format(z))) * " "
            pdb_file.write(ATOM_LINE.format(first_space, k, backbone[j]," " * (4 - len(backbone[j])), three_letter_code, "A", second_space, i, third_space, x,forth_space, y,fifth_space, z, sixth_space, b_factor, backbone[j][0]))
            k += 1
        i += 1
    if write_end:
        pdb_file.write(END_LINE)


def get_antigen_one_hot(antigen_seq, antigen_surface):
    """
    get antigen one hot from its sequence
    """
    # turn in to one-hot encoding matrix
    seq_matrix = np.zeros((len(antigen_seq), ANTIGEN_FEATURE_NUM))
    for i in range(len(antigen_seq)):
        seq_matrix[i][AA_DICT[antigen_seq[i]]] = 1
        seq_matrix[i][21] = antigen_surface[i]  # surface column

    return seq_matrix


def calculate_center_transformation(center_residue):
    """
    calculates the transformation that moves this residue center triangle to the origin triangle
    """
    translation = np.array([np.average(center_residue[:,i]) for i in range(3)])
    rotation, rmsd = R.align_vectors(CENTER_TRIANGLE, center_residue-translation)
    return rotation, translation


def move_to_global_frame(antigen_patches_xyz, antigen_patches_side_chains, patches_centers):
    """
    moves the antigen input to the reference frame
    """
    centered_antigen_patches = []
    centered_antigen_side_chains = []
    patch_mask = np.array(antigen_patches_xyz) != 0.0
    side_chain_mask = np.array(antigen_patches_side_chains) != 0.0

    for center, patch, mask, side_chains_patch, side_mask in zip(patches_centers, antigen_patches_xyz, patch_mask, antigen_patches_side_chains, side_chain_mask):
        rotation, translation = calculate_center_transformation(center)

        patch = np.reshape(patch, newshape=(patch.shape[0] * 5, 3))
        side_chains_patch = np.reshape(side_chains_patch, newshape=(side_chains_patch.shape[0] * 5, 3))

        patch = rotation.apply(patch - translation)
        side_chains_patch = rotation.apply(side_chains_patch - translation)

        patch = np.reshape(patch, newshape=(patch.shape[0] // 5, 15)) * mask
        side_chains_patch = np.reshape(side_chains_patch, newshape=(side_chains_patch.shape[0] // 5, 15)) * side_mask

        pad_patch = np.zeros((patch.shape[0] + 1, patch.shape[1]))
        pad_side_chains_patch = np.zeros((side_chains_patch.shape[0] + 1, side_chains_patch.shape[1]))

        pad_patch[:-1,:] = patch
        pad_side_chains_patch[:-1,:] = side_chains_patch

        centered_antigen_patches.append(pad_patch)
        centered_antigen_side_chains.append(pad_side_chains_patch)

    return centered_antigen_patches, centered_antigen_side_chains


def get_antigen_xyz(antigen_seq, antigen_residues):
    """
    get the antigen xyz coordinates
    """
    ag_xyz_matrix = np.zeros((len(antigen_seq), 15))

    # get the heavy coordinates
    for i in range(len(antigen_seq)):
        for j, atom in enumerate(["N", "CA", "C", "O", "CB"]):
            if antigen_seq[i] != "-":
                if antigen_residues[i].has_id(atom):
                    ag_xyz_matrix[i][3*j:3*j+3] = antigen_residues[i][atom].get_coord()

    return ag_xyz_matrix


def get_antigen_surface(antigen_model):
    """
    calculate the antigen surface values
    """

    surface_values = str(sp.run(f"{SURFACE} {antigen_pdb}", shell=True, capture_output=True).stderr.decode("utf-8")).split("\n")[9:-1]
    return [float(i)/MAX_SURFACE_VALUE for i in surface_values if (i != 'double free or corruption (!prev)' and 'surface' not in i and 'area' not in i)]


def get_antibody_one_hot(heavy_seq, light_seq=None):
    """
    get antibody one hot from heavy and light chains sequences
    """
    if len(heavy_seq) > HEAVY_MAX_LENGTH:
        raise ValueError("Heavy chain is too long: {}, we support heavy chains of up to {} amino acids".format(len(heavy_seq), HEAVY_MAX_LENGTH))
    # pad the sequence with '-'
    heavy_padding = (HEAVY_MAX_LENGTH - (len(heavy_seq)))
    # turn in to one-hot encoding matrix
    seq_matrix = np.zeros((MAX_LENGTH + 1, FEATURE_NUM))
    for i in range(len(heavy_seq)):
        seq_matrix[i][AA_DICT[heavy_seq[i]]] = 1
        seq_matrix[i][21] = 1  # heavy column

    if light_seq is not None:
        if len(light_seq) > LIGHT_MAX_LENGTH:
            raise ValueError("Light chain is too long: {}, we support light chains of up to {} amino acids".format(len(light_seq), LIGHT_MAX_LENGTH))
        for i in range(len(light_seq)):
            seq_matrix[i+len(heavy_seq)+ heavy_padding][AA_DICT[light_seq[i]]] = 1
            seq_matrix[i+len(heavy_seq)+ heavy_padding ][22] = 1  # light column
        seq_matrix[MAX_LENGTH][23] = 1  # light chain transformation
    return seq_matrix


def get_antigen_one_hot_xyz(antigen_model, known_epitope=None):
    """
    get antigen one hot and xyz coordinates
    """
    antigen_seq_list, antigen_residues_list = get_seq_aa(antigen_model, only_ca=True)

    antigen_seq = "".join(antigen_seq_list)
    antigen_residues = []
    for chain_aa in antigen_residues_list:
        antigen_residues += chain_aa

    if known_epitope is not None:
        assert len(known_epitope) == len(antigen_residues)

    antigen_surface = get_antigen_surface(antigen_model)
    if len(antigen_seq) != len(antigen_surface):
        raise ValueError(f"Antigen sequence length and surface don't match!: {len(antigen_seq)}, {len(antigen_surface)}")

    antigen_xyz = get_antigen_xyz(antigen_seq, antigen_residues)
    antigen_one_hot = get_antigen_one_hot(antigen_seq, antigen_surface)
    antigen_side_chain_xyz = TORSION_CALCULATOR.calculate_torsion(antigen_residues)

    patches_centers = []
    patches_xyz = []
    patches_side_chain_xyz = []
    patches_one_hot = []

    for aa in range(len(antigen_seq)):
        if antigen_surface[aa] > 0.0:  # the residue is in the surface

            # the residue is in the known epitope
            if known_epitope is not None and not known_epitope[aa]:
                continue

            # the residue has all of the required atoms for moving to the gloal reference frame
            if (antigen_residues[aa].has_id('N') and antigen_residues[aa].has_id('CA') and antigen_residues[aa].has_id('C')):

                patch_center = np.array([list(antigen_residues[aa][atom].get_coord()) for atom in ['N', 'CA', 'C']])

                patch_xyz = np.zeros((MAX_LENGTH_ANTIGEN, 15))
                patch_side_chain = np.zeros((MAX_LENGTH_ANTIGEN, 15))
                patch_one_hot = np.zeros((MAX_LENGTH_ANTIGEN + 1, ANTIGEN_FEATURE_NUM))

                patch_xyz[:len(antigen_seq),:] = np.array(antigen_xyz)
                patch_side_chain[:len(antigen_seq),:] = np.array(antigen_side_chain_xyz)
                patch_one_hot[:len(antigen_seq),:] = np.array(antigen_one_hot)

                patch_one_hot[MAX_LENGTH_ANTIGEN][ANTIGEN_FEATURE_NUM - 2] = 1  # docking column
                patch_one_hot[aa][ANTIGEN_FEATURE_NUM - 1] = 1  # interaction column

                patches_centers.append(patch_center)
                patches_xyz.append(patch_xyz)
                patches_side_chain_xyz.append(patch_side_chain)
                patches_one_hot.append(patch_one_hot)

    return antigen_seq, patches_one_hot, patches_xyz, patches_side_chain_xyz, patches_centers


def get_antigen_input(antigen_model, known_epitope=None):
    """
    get the antigen input for the docking network
    """
    if not antigen_model:  # only folding, no docking
        return None, np.zeros((1, MAX_LENGTH_ANTIGEN + 1, 15 + 15 + ANTIGEN_FEATURE_NUM))

    antigen_seq, patches_one_hot, patches_xyz, patches_side_chain_xyz, patches_centers = get_antigen_one_hot_xyz(antigen_model=antigen_model, known_epitope=known_epitope)
    patches_centered_xyz, patches_centered_sides = move_to_global_frame(patches_xyz, patches_side_chain_xyz, patches_centers)

    antigen_x = [np.concatenate((i, j, k), axis=-1) for i, j, k in zip(patches_one_hot, patches_centered_xyz, patches_centered_sides)]
    return antigen_seq, np.array(antigen_x)


def get_antibody_input(antibody_sequence):
    """
    get the antibody input for the docking network
    """
    heavy_seq, light_seq = separate_antibody_chains(antibody_sequence)
    antibody_x = get_antibody_one_hot(heavy_seq, light_seq)
    return antibody_x


def convert_dock_input_to_score_input(ab_dock_input, at_dock_input, dock_output):
    """
    """
    antibody_xyz_mask = tf.expand_dims(tf.math.logical_not(tf.math.reduce_all(tf.math.equal(ab_dock_input, 0), axis=-1))[:,:-1], axis=-1)
    antigen_xyz_mask = at_dock_input[:, :-1, 24:] != 0.0

    pred_ab_ = dock_output["light_orientation"] * tf.cast(antibody_xyz_mask, dtype=tf.float32)
    pred_ag_ = dock_output["docking"] * tf.cast(antigen_xyz_mask, dtype=tf.float32)

    predicted_antibody = np.pad(pred_ab_,[[0,0],[0,1],[0,0]], mode='constant', constant_values=0.0)
    predicted_antigen = np.pad(pred_ag_,[[0,0],[0,1],[0,0]], mode='constant', constant_values=0.0)

    ab_score_input = np.concatenate([ab_dock_input, predicted_antibody], axis=-1)
    ag_score_input = np.concatenate([at_dock_input[:,:,:24], predicted_antigen], axis=-1)

    return ab_score_input, ag_score_input, pred_ab_, pred_ag_